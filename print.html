<!DOCTYPE HTML>
<html lang="es" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>La plataforma de desarrollo GLib/GTK</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./src/assets/css/custom.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="content/00-intro/title.html">La plataforma de desarrollo GLib/GTK</a></li><li class="chapter-item expanded "><a href="content/00-intro/intro.html"><strong aria-hidden="true">1.</strong> Introducción</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/00-intro/glib-and-gtk.html"><strong aria-hidden="true">1.1.</strong> ¿Qué es GLib y GTK?</a></li><li class="chapter-item expanded "><a href="content/00-intro/gnome-desktop.html"><strong aria-hidden="true">1.2.</strong> El escritorio GNOME</a></li><li class="chapter-item expanded "><a href="content/00-intro/prerequisites.html"><strong aria-hidden="true">1.3.</strong> Prerrequisitos</a></li><li class="chapter-item expanded "><a href="content/00-intro/why-and-when-c.html"><strong aria-hidden="true">1.4.</strong> ¿Por qué y cuándo se usa el lenguaje C?</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/00-intro/separate-backend.html"><strong aria-hidden="true">1.4.1.</strong> Separación de backend del frontend</a></li><li class="chapter-item expanded "><a href="content/00-intro/other-aspects.html"><strong aria-hidden="true">1.4.2.</strong> Otros aspectos a tener en cuenta</a></li></ol></li><li class="chapter-item expanded "><a href="content/00-intro/learning-path.html"><strong aria-hidden="true">1.5.</strong> Ruta de aprendizaje</a></li><li class="chapter-item expanded "><a href="content/00-intro/environment.html"><strong aria-hidden="true">1.6.</strong> El entorno de desarrollo</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="content/01-glib/glib.html"><strong aria-hidden="true">2.</strong> GLib, la biblioteca principal</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/01-glib/basics.html"><strong aria-hidden="true">2.1.</strong> Lo esencial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/01-glib/type-def.html"><strong aria-hidden="true">2.1.1.</strong> Definiciones de tipo</a></li><li class="chapter-item expanded "><a href="content/01-glib/freq-macros.html"><strong aria-hidden="true">2.1.2.</strong> Macros de uso frecuente</a></li><li class="chapter-item expanded "><a href="content/01-glib/debug-macros.html"><strong aria-hidden="true">2.1.3.</strong> Macros de depuración</a></li><li class="chapter-item expanded "><a href="content/01-glib/memory.html"><strong aria-hidden="true">2.1.4.</strong> Memoria</a></li><li class="chapter-item expanded "><a href="content/01-glib/str-handling.html"><strong aria-hidden="true">2.1.5.</strong> Manejo de string</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.</strong> Estructura de datos</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.1.</strong> Listas</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.2.</strong> Árboles</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.3.</strong> Tablas hash</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.3.</strong> El bucle del evento principal</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.</strong> Otras características</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Programación orientada a objetos en C</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.</strong> Una suave introducción a GObject</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> GTK</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.1.</strong> Ejemplo de una arquitectura de código de aplicación GTK</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.</strong> Lectura adicional</div></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="content/00-intro/bibliography.html">Bibliografía</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">La plataforma de desarrollo GLib/GTK</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/gersonbdev/glib-gtk-libro" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="la-plataforma-de-desarrollo-glibgtk"><a class="header" href="#la-plataforma-de-desarrollo-glibgtk">La plataforma de desarrollo GLib/GTK</a></h1>
<p><em>Por Sébastien Wilmet y Gerson Benavides</em></p>
<p align="center">
<img src="https://gersonbdev.github.io/glib-gtk-libro/assets/img/logo-gtk.svg" alt="Logo de GTK" width="256" />
</p>
<h2 id="descargas"><a class="header" href="#descargas">Descargas</a></h2>
<ul>
<li><a href="https://people.gnome.org/%7Eswilmet/glib-gtk-dev-platform.pdf">Libro en formato PDF en inglés</a></li>
<li><a href="https://raw.githubusercontent.com/gersonbdev/glib-gtk-libro/master/latex/glib-gtk-libro.pdf">Libro en formato PDF en español</a></li>
<li><a href="https://github.com/swilmet/glib-gtk-book">Repositorio del libro en inglés</a></li>
<li><a href="https://github.com/gersonbdev/glib-gtk-libro">Repositorio del libro en español</a></li>
</ul>
<h2 id="creditos"><a class="header" href="#creditos">Creditos</a></h2>
<p>Este texto esta basado en el libro <a href="https://people.gnome.org/%7Eswilmet/glib-gtk-book/">&quot;The GLib/GTK+ Development Platform&quot;</a> escrito por <a href="https://github.com/swilmet">Sébastien Wilmet</a>. Actualmente, el texto esta siendo escrito por <a href="https://github.com/gersonbdev">Gerson Benavides</a>.</p>
<p>Se agradece los aportes de Christian Stadelmann, Errol van de l’Isle, Andrew Colin Kissa y Link
Dupont.</p>
<blockquote>
<p><strong>⚠ Advertencia:</strong> Este &quot;libro&quot; está lejos de estar terminado, estás leyendo la versión 0.8. Si tiene algún comentario, no dude en ponerse en contacto con el editor en <a href="mailto:gersonbdev@gmail.com">gersonbdev@gmail.com</a>.</p>
</blockquote>
<h2 id="licencia"><a class="header" href="#licencia">Licencia</a></h2>
<p><img src="https://gersonbdev.github.io/glib-gtk-libro/assets/img/license-cc-by-sa-88x31.png" alt="License CC BY-SA" /></p>
<p>Este trabajo está autorizado bajo una licencia internacional Creative Commons Attribution-ShareAlike 4.0:</p>
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/">creativecommons.org/licenses/by-sa/4.0/</a></p>
<p>Algunas secciones están basadas en el libro <em>GTK+ / Gnome Application Development</em>, escrito en 1999, editado por New Riders Publishing y con licencia de Open Publication License. La última versión de la licencia de publicación abierta se puede encontrar en:</p>
<p><a href="http://www.opencontent.org/openpub/">www.opencontent.org/openpub/</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducción"><a class="header" href="#introducción">Introducción</a></h1>
<p>Este texto es una guía para comenzar con la plataforma de desarrollo GLib/GTK, haciendo uso del lenguaje C. En ocasiones se asumirá que el lector usa un sistema similar a Unix.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="qué-es-glib-y-gtk"><a class="header" href="#qué-es-glib-y-gtk">¿Qué es GLib y GTK?</a></h1>
<p>En términos generales, GLib es un conjunto de bibliotecas: GLib core, GObject y GIO. Esas tres bibliotecas se desarrollan en el mismo repositorio de Git llamado <em>glib</em>, por lo que cuando se hace referencia a &quot;GLib&quot;, puede significar &quot;GLib core&quot; o el conjunto más amplio que incluye también GObject y GIO.</p>
<p>GLib core proporciona manejo de estructura de datos para C (listas enlazadas, árboles, tablas hash, ...), envoltorios de portabilidad, un bucle de eventos, hilos, carga dinámica de módulos y muchas funciones de utilidad.</p>
<p>GObject -- que depende del núcleo GLib -- simplifica la programación orientada a objetos y los paradigmas de programación dirigida por eventos en C. La programación dirigida por eventos no solo es útil para interfaces gráficas de usuario (con eventos de usuario como pulsaciones de teclas y clics del mouse), pero también para demonios que responden a cambios de hardware (una memoria USB insertada, un segundo monitor conectado, una impresora con poco papel), o software que escucha conexiones de red o mensajes de otros procesos, etc.</p>
<p>GIO -- que depende de GLib core y GObject -- proporciona API de alto nivel para entrada/salida: lectura de un archivo local, un archivo remoto, un flujo de red, comunicación entre procesos con D-Bus y muchos más.</p>
<p>Las bibliotecas GLib se pueden utilizar para escribir servicios del sistema operativo, bibliotecas, utilidades de línea de comandos y demás. GLib ofrece API de mayor nivel que el estándar POSIX; por lo tanto, es más cómodo escribir un programa en C con GLib.</p>
<p>GTK es un conjunto de herramientas de widgets basado en GLib que se puede utilizar para desarrollar aplicaciones con una interfaz gráfica de usuario (GUI). Un “widget” es un elemento de la GUI, por ejemplo, un botón, un texto, un menú, etc. Y hay algunos tipos especiales de widgets que se denominan “containers”, que pueden contener otros widgets, para ensamblar los elementos en una ventana. GTK proporciona una amplia gama de widgets y contenedores.</p>
<p>La primera versión de GTK +, o GIMP Tool Kit, fue escrita principalmente por Peter Mattis en 1996 para el GIMP (Programa de manipulación de imágenes GNU), pero se ha convertido rápidamente en una biblioteca de uso general. El “+” se ha agregado más tarde para distinguir entre la versión original y una nueva versión que agregó características orientadas a objetos. GLib comenzó como parte de GTK +, pero ahora es una biblioteca independiente.</p>
<blockquote>
<p><strong>📌 Nota:</strong> El nombre &quot;The GIMP Tool Kit&quot; ahora rara vez se usa, hoy se conoce más comúnmente como GTK para abreviar.</p>
</blockquote>
<p>Las API GLib y GTK están documentadas con GTK-Doc. Los comentarios especiales están escritos en el código fuente y GTK-Doc extrae esos comentarios para generar páginas HTML.</p>
<p>Aunque GLib y GTK están escritos en C, los enlaces de lenguaje están disponibles para JavaScript, Python, Perl y muchos otros lenguajes de programación. Al principio, se crearon enlaces manuales, que debían actualizarse cada vez que cambiaba la API de la biblioteca. Hoy en día, los enlaces de lenguaje son genéricos y, por lo tanto, se actualizan automáticamente cuando, por ejemplo, se agregan nuevas funciones, esto es gracias a GObject Introspection. Se agregan anotaciones especiales a los comentarios de GTK-Doc, para exponer más información de la que puede proporcionar la sintaxis de C, por ejemplo, sobre la transferencia de propiedad de contenido asignado dinámicamente.</p>
<blockquote>
<p><strong>📌 Nota:</strong> Por ejemplo, si necesita liberar el valor de retorno.</p>
</blockquote>
<p>Además, las anotaciones también son útiles para el programador en C porque es una forma buena y concisa de documentar ciertos aspectos recurrentes de la API.</p>
<p>GLib y GTK son parte del Proyecto GNU, cuyo objetivo general es desarrollar un sistema operativo libre (llamado GNU) más aplicaciones que lo acompañen. GNU significa “GNU’s Not Unix”, una forma divertida de decir que el sistema operativo GNU es compatible con Unix. Puede obtener más información sobre
GNU en <a href="https://www.gnu.org">www.gnu.org</a>.</p>
<p>El sitio web de GLib/GTK es: <a href="http://www.gtk.org">www.gtk.org</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="el-escritorio-gnome"><a class="header" href="#el-escritorio-gnome">El escritorio GNOME</a></h1>
<p>Un proyecto importante para GLib y GTK es GNOME. GNOME, que también forma parte de GNU, es un entorno de escritorio libre iniciado en 1997 por Miguel de Icaza y Federico Mena-Quintero. GNOME hace un uso extensivo de GTK, y el último ahora es desarrollado principalmente por desarrolladores de GNOME.</p>
<p>&quot;GNOME&quot; es en realidad un acrónimo: GNU Network Object Model Environment.</p>
<blockquote>
<p><strong>📌 Nota:</strong> En cuanto a GTK, el nombre completo de GNOME rara vez se usa y no refleja la realidad actual.</p>
</blockquote>
<p>Originalmente, el proyecto tenía la intención de crear un marco para objetos de aplicación, similar a las tecnologías OLE y COM de Microsoft. Sin embargo, el alcance del proyecto se expandió rápidamente; quedó claro se requería un trabajo preliminar sustancial antes de que la parte del nombre de &quot;network object&quot; pudiera convertirse en realidad. Las versiones antiguas de GNOME incluían una arquitectura de incrustación de objetos llamada Bonobo, y GNOME 1.0 incluía un ORB CORBA rápido y ligero llamado ORBit. Bonobo ha sido reemplazado por D-Bus un sistema de comunicación entre procesos.</p>
<p>GNOME tiene dos caras importantes. Desde la perspectiva del usuario, es un entorno de escritorio integrado y una suite de aplicaciones. Desde la perspectiva del programador, es un marco de desarrollo de aplicaciones (compuesto por numerosas bibliotecas útiles que se basan en GLib y GTK). Las aplicaciones
escritas con las bibliotecas de GNOME funcionan bien incluso si el usuario no está ejecutando el entorno de escritorio, pero se integran bien con el escritorio de GNOME si está disponible.</p>
<p>El entorno de escritorio incluye un &quot;shell&quot; para cambiar de tareas y ejecutar programas, un &quot;centro de control&quot; para la configuración, muchas aplicaciones como un administrador de archivos, un navegador web, un reproductor de películas, etc. línea de comando tradicional de Unix detrás de una interfaz gráfica fácil de usar.</p>
<p>El marco de desarrollo de GNOME permite escribir aplicaciones interoperables, coherentes y fáciles de usar. Los diseñadores de sistemas de ventanas como X11 o Wayland tomaron la decisión deliberada de no imponer ninguna política de interfaz de usuario a los desarrolladores; GNOME agrega una &quot;capa de política&quot;, creando una apariencia coherente. Las aplicaciones GNOME terminadas funcionan bien con el escritorio GNOME, pero también se pueden usar de forma &quot;independiente&quot; -- los usuarios solo necesitan instalar las bibliotecas compartidas de GNOME. Una aplicación GNOME no está vinculada a un sistema de ventanas específico, GTK proporciona backends para X Window System, Wayland, Mac OS X, Windows e incluso para un navegador web.</p>
<p>En el momento de escribir este artículo, hay nuevas versiones estables de GLib, GTK y GNOME cada seis meses, alrededor de marzo y septiembre. Un número de versión tiene la forma &quot;<code>major.minor.micro</code>&quot;, donde &quot;<code>minor</code>&quot; es incluso para versiones estables e isodd para versiones inestables. Por ejemplo, las versiones 3.18. * Son estables, pero las versiones 3.19. * Son inestables. Una nueva versión micro estable (por ejemplo, 3.18.0 → 3.18.1) no agrega nuevas funciones, solo actualizaciones de traducción, corrección de errores y mejoras de rendimiento. Los componentes de GNOME deben instalarse con las mismas versiones, junto con la versión de GTK y GLib lanzada al mismo tiempo; por ejemplo, es una mala idea ejecutar un demonio GNOME en la versión 3.18 con el centro de control en la versión 3.16. En el momento de escribir este artículo, las últimas versiones estables son: GLib 2.46, GTK 3.18 y GNOME 3.18, todas lanzadas al mismo tiempo en septiembre de 2015. Para una biblioteca, un nuevo número de versión principal generalmente significa que ha habido una interrupción de la API, pero afortunadamente la versión principal anterior. Las versiones se pueden instalar en paralelo con la nueva versión. Durante un ciclo de desarrollo (por ejemplo, 3.19), no hay garantías de estabilidad API para <em>nuevas</em> funciones; pero al ser uno de los primeros en adoptarlo, sus comentarios son útiles para descubrir más rápidamente fallas y errores de diseño.</p>
<p>Más información sobre GNOME: <a href="https://www.gnome.org/">www.gnome.org</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prerrequisitos"><a class="header" href="#prerrequisitos">Prerrequisitos</a></h1>
<p>Este libro asume que ya tiene algo de práctica en programación. A continuación, se muestra una lista de requisitos previos recomendados, con referencias de libros.</p>
<ul>
<li>
<p>Este texto supone que ya conoces el lenguaje C. El libro de referencia es <em><strong>The C Programming Language</strong></em>, de Brian Kernighan y Dennis Ritchie <span class="k-r-book"></span>.</p>
</li>
<li>
<p>La programación orientada a objetos (OOP) también es necesaria para aprender GObject. Debe estar familiarizado con conceptos como herencia, una interfaz, un método virtual o polimorfismo. Un buen libro, con más de sesenta pautas, es <em><strong>Object-Oriented Design Heuristics</strong></em>, de Arthur Riel <span class="oop-book"></span>.</p>
</li>
<li>
<p>Es útil haber leído un libro sobre estructuras de datos y algoritmos, pero puede aprenderlo en paralelo. Un libro recomendado es <em><strong>The Algorithm Design Manual</strong></em>, de Steven Skiena <span class="algo-book"></span>.</p>
</li>
<li>
<p>Si desea desarrollar su software en un sistema similar a Unix, otro requisito previo es saber cómo funciona Unix y estar familiarizado con la línea de comandos, un poco de scripts de shell y cómo escribir un Makefile. Un posible libro es <em><strong>UNIX for the Impatient</strong></em>, de Paul Abrahams <span class="unix-impatient"></span>.</p>
</li>
<li>
<p>No es estrictamente necesario, pero se recomienda encarecidamente utilizar un sistema de control de versiones como Git. Un buen libro es <em><strong>Pro Git</strong></em>, de Scott Chacon <span class="pro-git"></span>.</p>
</li>
</ul>
<script>
/* Asignacion de referencias en todo la pagina */

let i = 0;

let ref01 = document.getElementsByClassName("k-r-book");
for( i = 0; i < ref01.length; i++ ) {
    ref01[i].innerHTML = "<a href=\"./bibliography.html#k-r-book\">[1]</a>";
}

let ref02 = document.getElementsByClassName("oop-book");
for( i = 0; i < ref02.length; i++ ) {
    ref02[i].innerHTML = "<a href=\"./bibliography.html#oop-book\">[2]</a>";
}

let ref03 = document.getElementsByClassName("algo-book");
for( i = 0; i < ref03.length; i++ ) {
    ref03[i].innerHTML = "<a href=\"./bibliography.html#algo-book\">[4]</a>";
}

let ref04 = document.getElementsByClassName("unix-impatient");
for( i = 0; i < ref04.length; i++ ) {
    ref04[i].innerHTML = "<a href=\"./bibliography.html#unix-impatient\">[5]</a>";
}

let ref05 = document.getElementsByClassName("pro-git");
for( i = 0; i < ref05.length; i++ ) {
    ref05[i].innerHTML = "<a href=\"./bibliography.html#pro-git\">[6]</a>";
}

</script><div style="break-before: page; page-break-before: always;"></div><h1 id="por-qué-y-cuándo-se-usa-el-lenguaje-c"><a class="header" href="#por-qué-y-cuándo-se-usa-el-lenguaje-c">¿Por qué y cuándo se usa el lenguaje C?</a></h1>
<p>Las bibliotecas GLib y GTK pueden ser utilizadas por otros lenguajes de programación además de C. Gracias a GObject Introspection, los enlaces automáticos están disponibles para una gran variedad de lenguajes, de manera que puedan ser usadas todas las bibliotecas basadas en GObject por estos. Los enlaces oficiales de GNOME están disponibles para los siguientes lenguajes:</p>
<table><thead><tr><th>Lenguaje</th><th>v3</th><th>v4</th></tr></thead><tbody>
<tr><td><a href="https://www.gtkmm.org/en/index.html" title="gtkmm">C++</a></td><td>☑</td><td>☑</td></tr>
<tr><td><a href="https://gjs.guide/" title="GJS">JavaScript</a></td><td>☑</td><td>☑</td></tr>
<tr><td><a href="https://pygobject.readthedocs.io/en/latest/" title="PyGObject">Python</a></td><td>☑</td><td>☑</td></tr>
<tr><td><a href="https://gtk-rs.org/" title="gtk-rs">Rust</a></td><td>☑</td><td>☑</td></tr>
<tr><td><a href="https://valadoc.org/" title="Vala">Vala</a></td><td>☑</td><td>☑</td></tr>
</tbody></table>
<blockquote>
<p><strong>📌 Nota:</strong> Aunque existen enlaces a más lenguajes, los expresados en la tabla son los más activos es sus repositorios y con una mayor comunidad.</p>
</blockquote>
<p>Una buena alternativa es Vala, el cual es un nuevo lenguaje de programación basado en GObject que integra las peculiaridades de GObject directamente en su sintaxis similar a C#. De manera que, todo el código hecho en Vala es traducido a código en C, el cual hace uso de GObject directamente, esto puede resultar útil si desea código cercano a C pero haciendo uso de un lenguaje más moderno.</p>
<blockquote>
<p><strong>📌 Nota:</strong> Tenga en cuenta que el lenguaje Vala podría considerarse un lenguaje de nicho, teniendo una comunidad pequeña si es comparado con lenguajes más populares.</p>
</blockquote>
<p>Más allá de los enlaces oficiales de GNOME, GLib y GTK se pueden usar en más de una docena de lenguajes de programación, con un nivel de soporte variable. Entonces, <em>¿por qué y cuándo elegir el lenguaje C?</em>.</p>
<p>Por ejemplo, para escribir un demonio en un sistema tipo Unix, C es el idioma <em>predeterminado</em>. Pero es menos obvio que lenguaje usar para una aplicación. Para responder a la pregunta, veamos primero cómo estructurar el código base de una aplicación.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="separación-de-backend-del-frontend"><a class="header" href="#separación-de-backend-del-frontend">Separación de backend del frontend</a></h1>
<p>Una buena práctica es separar la interfaz gráfica de usuario del resto de la aplicación. Por diversas razones, la interfaz gráfica de una aplicación tiende a ser una pieza de software excepcionalmente volátil y en constante cambio. Es el foco de la mayoría de las solicitudes de cambio de los usuarios. Es difícil planificar y ejecutar bien la primera vez; a menudo descubrirá que algún aspecto es desagradable de usar solo después de haberlo escrito. A veces es deseable tener varias interfaces de usuario diferentes, por ejemplo, una versión de línea de comandos o una interfaz basada en web.</p>
<p>En términos prácticos, esto significa que cualquier aplicación grande debe tener una separación radical entre sus diversos <em>frontends</em> o interfaces y el <em>backend</em>. El backend debe contener todas las &quot;partes duras&quot;: sus algoritmos y estructuras de datos, el trabajo real realizado por la aplicación. Piense en ello como un &quot;modelo&quot; abstracto que se muestra y manipula el usuario.</p>
<p>Cada interfaz debe ser una &quot;vista&quot; y un &quot;controlador&quot;. Como una &quot;vista&quot;, la interfaz debe anotar cualquier cambio en el backend y cambiar la pantalla en consecuencia. Como un &quot;controlador&quot;, la interfaz debe permitir al usuario transmitir solicitudes de cambio al backend (define cómo las manipulaciones de la interfaz se traducen en cambios en el modelo).</p>
<p>Hay muchas formas de disciplinarse para mantener su aplicación separada. Un par de ideas útiles:</p>
<ul>
<li>Escriba el backend como una biblioteca. Al principio, la biblioteca puede ser interna a la aplicación y estar vinculada estáticamente, sin garantías de estabilidad API/ABI. Cuando el proyecto crezca, y si el código es útil para otros programas, puede convertir fácilmente su backend en una biblioteca compartida.</li>
<li>Escriba al menos dos interfaces desde el principio; uno o ambos pueden ser prototipos feos, solo desea tener una idea de cómo estructurar el backend. Recuerde, las interfaces deben ser fáciles; el backend tiene las partes difíciles.</li>
</ul>
<p>El lenguaje C es una buena opción para la parte de backend de una aplicación. Al utilizar GObject y GObject Introspection, su biblioteca estará disponible para otros proyectos escritos en varios lenguajes de programación. Por otro lado, una biblioteca de Python o JavaScript no se puede utilizar en otros lenguajes. Para las interfaces, un idioma de nivel superior puede ser más conveniente, dependiendo de los idiomas con los que ya domine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="otros-aspectos-a-tener-en-cuenta"><a class="header" href="#otros-aspectos-a-tener-en-cuenta">Otros aspectos a tener en cuenta</a></h1>
<p>Si tiene dudas sobre el idioma a elegir, aquí hay otros aspectos a tener en cuenta. Tenga en cuenta que este texto está un poco sesgado ya que se eligió el lenguaje C.</p>
<p>C es un lenguaje de tipo estático: los tipos de variables y los prototipos de funciones en un programa se conocen en el momento de la compilación. El compilador descubre muchos errores triviales, como un error tipográfico en el nombre de una función. El compilador también es de gran ayuda cuando se hacen refactorizaciones de código, lo cual es esencial para el mantenimiento a largo plazo de un programa. Por ejemplo, cuando divide una clase en dos, si el código que usa la clase inicial no se actualiza correctamente, el compilador se lo informará amablemente.</p>
<blockquote>
<p><strong>📌 Nota:</strong> Bueno, amablemente quizás no sea la mejor descripción, arrojar un montón de errores está más cerca de la realidad.</p>
</blockquote>
<p>Con el desarrollo basado en pruebas (TDD), y escribiendo pruebas unitarias para <em>todo</em>, también es factible escribir una enorme base de código en un lenguaje de tipo dinámico como Python. Con una muy buena cobertura de código, las pruebas unitarias también detectarán errores al refactorizar el código. Pero las pruebas unitarias pueden ser mucho más lentas de ejecutar que compilar el código, ya que también prueba el comportamiento del programa. Por lo tanto, puede que no sea conveniente ejecutar todas las pruebas unitarias al realizar refactorizaciones de código. ¡Por supuesto, escribir pruebas unitarias también es una buena práctica para una base de código C! Sin embargo, para la parte GUI del código, escribir pruebas unitarias a menudo no es una tarea de alta prioridad si la aplicación está bien probada por sus desarrolladores.</p>
<p>C es un lenguaje escrito explícitamente: los tipos de variables son visibles en el código. Es una forma de auto-documentar el código; por lo general, no es necesario agregar comentarios para explicar qué contienen las variables. Conocer el tipo de variable es importante para comprender el código, saber qué representa la variable y qué funciones se pueden llamar sobre ella. En un asunto relacionado, el objeto <em>self</em> se pasa explícitamente como un argumento de función. Por lo tanto, cuando se accede a un atributo a través del puntero <em>self</em>, se sabe de dónde procede el atributo. Algunos lenguajes orientados a objetos tienen <em>esta</em> palabra clave para ese propósito, pero a veces es opcional como en C ++ o Java. En este último caso, una función útil del editor de texto es resaltar atributos de manera diferente, por lo que incluso cuando no se usa <em>esta</em> palabra clave, usted sabe que es un atributo y no una variable local. Con el objeto <em>self</em> pasado como argumento, no hay posibles confusiones.</p>
<p>El lenguaje C tiene una <em>cadena de herramientas</em> muy buena: compiladores estables (GCC, Clang,...), Editores de texto (Vim, Emacs,...), Depuradores (GDB, Valgrind,...), Herramientas de análisis estático, ...</p>
<p>Para algunos programas, un recolector de basura no es apropiado porque pausa el programa regularmente para liberar la memoria no utilizada. Para secciones de código críticas, como animaciones en tiempo real, no es conveniente pausar el programa (un recolector de basura a veces puede ejecutarse durante varios segundos). En este caso, la gestión manual de la memoria como en C es una solución.</p>
<p>Menos importante, pero útil; la verbosidad de C en combinación con las convenciones GLib/GTK tiene una ventaja: el código se puede buscar fácilmente con un comando como <code>grep</code>. Por ejemplo, la función <code>gtk_widget_show()</code> contiene el espacio de nombres (<code>gtk</code>), la clase (<code>widget</code>) y el método (<code>show</code>). Con un lenguaje orientado a objetos, la sintaxis es generalmente <code>object.show()</code>. Si se busca &quot;show&quot; en el código, probablemente habrá más falsos positivos, por lo que se necesita una herramienta más inteligente. Otra ventaja es que conocer el espacio de nombres y la clase de un método puede ser útil al leer el código, es otra forma de auto-documentación.</p>
<p>Más importante aún, la documentación de la API GLib/GTK está escrita principalmente para el lenguaje C. No es conveniente leer la documentación de C mientras se programa en otro idioma. Algunas herramientas están actualmente en desarrollo para generar la documentación de la API para otros lenguajes de destino, por lo que es de esperar que en el futuro ya no sea un problema.</p>
<p>GLib/GTK están escritos en C. Entonces, cuando se programa en C, no hay capa adicional. Una capa adicional es potencialmente una fuente de errores adicionales y cargas de mantenimiento. Además, usar el lenguaje C probablemente
sea mejor para propósitos pedagógicos. Un lenguaje de nivel superior puede ocultar algunos detalles sobre GLib/GTK. Por lo tanto, el código es más corto, pero cuando tiene un problema, debe comprender no solo cómo funciona la función de la biblioteca, sino también cómo funciona el enlace del idioma.</p>
<p>Dicho esto, si:</p>
<ul>
<li>No se siente cómodo en C.</li>
<li>Ya domina un lenguaje de nivel superior con compatibilidad con GObject Introspection.</li>
<li>Planea escribir solo una pequeña aplicación o complemento.</li>
</ul>
<p>Elegir un lenguaje de nivel superior tiene mucho sentido.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ruta-de-aprendizaje"><a class="header" href="#ruta-de-aprendizaje">Ruta de aprendizaje</a></h1>
<p>Normalmente, esta sección debería llamarse &quot;Estructura del libro&quot;, pero como puede ver, el libro está lejos de estar terminado, por lo que la sección se llama &quot;Ruta de aprendizaje&quot;.</p>
<p>El camino de aprendizaje lógico es:</p>
<ol>
<li>Los fundamentos del núcleo GLib;</li>
<li>Programación orientada a objetos en C y los conceptos básicos de GObject;</li>
<li>GTK y GIO en paralelo.</li>
</ol>
<p>Dado que GTK se basa en GLib y GObject, es mejor comprender primero los conceptos básicos de esas dos bibliotecas. Algunos tutoriales se sumergen directamente en GTK, por lo que después de un corto período de tiempo puede mostrar una ventana con texto y tres botones; es divertido, pero conocer GLib y GObject no es un lujo si quiere comprender lo que está haciendo, y una aplicación GTK realista utiliza ampliamente las bibliotecas GLib. GTK y GIO se pueden aprender en paralelo --- una vez que comience a usar GTK, verá que algunas partes que no son GUI están basadas en GIO.</p>
<p>Así que este libro comienza con la biblioteca principal GLib (parte I p. 12), luego presenta la Programación Orientada a Objetos en C (parte II p. 36) seguida de un capítulo de Lecturas Adicionales (p. 67)</p>
<blockquote>
<p><strong>📌 Nota:</strong> Estas referencias son del libro en PDF <a href="https://raw.githubusercontent.com/gersonbdev/glib-gtk-libro/master/latex/glib-gtk-libro.pdf">La plataforma de desarrollo GLib/GTK: Una guía de introducción</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="el-entorno-de-desarrollo"><a class="header" href="#el-entorno-de-desarrollo">El entorno de desarrollo</a></h1>
<p>Esta sección describe el entorno de desarrollo que se usa normalmente al programar con GLib y GTK en un sistema Unix.</p>
<p>En una distribución GNU / Linux, a menudo se puede instalar un solo paquete o grupo para obtener un entorno de desarrollo C completo, que incluye, entre otros:</p>
<ul>
<li>Un compilador compatible con C89, GCC por ejemplo.</li>
<li>El depurador GNU GDB.</li>
<li>GNU Make.</li>
<li>Los Autotools (Autoconf, Automake y Libtool).</li>
<li>Las páginas del manual: the Linux kernel and the glibc.</li>
</ul>
<blockquote>
<p><strong>📌 Nota:</strong> No confundir la biblioteca GNU C (glibc) con GLib. La primera es de nivel inferior.</p>
</blockquote>
<p>Para utilizar GLib y GTK como desarrollador, existen varias soluciones:</p>
<ul>
<li>Los encabezados y la documentación se pueden instalar con el administrador de paquetes. El nombre de los paquetes suele terminar con uno de los siguientes sufijos: <code>-devel</code>, <code>-dev</code> o <code>-doc</code>. Por ejemplo <code>glib2-devel</code> y <code>glib2-doc</code> en Fedora.</li>
<li>Las últimas versiones de GLib y GTK se pueden instalar con Jhbuild: <a href="https://wiki.gnome.org/Projects/Jhbuild">wiki.gnome.org/Projects/Jhbuild</a></li>
</ul>
<p>Para leer la documentación de la API de GLib y GTK, Devhelp es una aplicación útil, si ha instalado el paquete -dev o -doc. Para el editor de texto o IDE, hay muchas opciones (y una fuente de muchos trolls): Vim, Emacs, gedit, Anjuta,
MonoDevelop/Xamarin Studio, Geany,... Un prometedor IDE especializado para GNOME es Builder, actualmente en desarrollo. Para crear una GUI con GTK, puede escribir directamente el código para hacerlo o puede usar Glade para diseñar la GUI gráficamente. Finalmente, GTK-Doc se usa para escribir documentación de API y agregar las anotaciones de GObject Introspection.</p>
<p>Cuando utilice GLib o GTK, preste atención a no utilizar API obsoletas para el código recién escrito. Asegúrese de leer la documentación más reciente. También están disponibles en línea en:</p>
<p><a href="https://developer.gnome.org/">developer.gnome.org</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glib-la-biblioteca-principal"><a class="header" href="#glib-la-biblioteca-principal">GLib, la biblioteca principal</a></h1>
<p>GLib es la biblioteca central de bajo nivel que forma la base para proyectos como GTK y GNOME. Proporciona estructuras de datos, funciones de utilidad, envoltorios de portabilidad y otras funciones esenciales, como un bucle de eventos e hilos. GLib está disponible en la mayoría de los sistemas similares a Unix y Windows.</p>
<p>Este capítulo cubre algunas de las funciones más utilizadas. GLib es simple y los conceptos son familiares; así que nos moveremos rápidamente. Para obtener una cobertura más completa de GLib, consulte la última documentación de la API que viene con la biblioteca (para el entorno de desarrollo, consulte la sección 1.9 en la p. 10). Por cierto: si tiene preguntas muy específicas sobre la implementación, no tema mirar el código fuente. Normalmente, la ocumentación contiene suficiente información, pero si encuentra un detalle faltante, por favor presente un error (por supuesto, lo mejor sería con un parche proporcionado).</p>
<p>Las diversas instalaciones de GLib están destinadas a tener una interfaz coherente; el estilo de codificación está orientado a semiobjetos, y los identificadores tienen el prefijo &quot;g&quot; para crear una especie de espacio de nombres.</p>
<p>GLib tiene algunos encabezados de nivel superior:</p>
<ul>
<li><code>glib.h</code>, el encabezado principal.</li>
<li><code>gmodule.h</code> para carga dinámica de módulos.</li>
<li><code>glib-unix.h</code> para API específicas de Unix.</li>
<li><code>glib/gi18n.h</code> y <code>glib/gi18n-lib.h</code> para la internacionalización;</li>
<li><code>glib/gprintf.h</code> y <code>glib/gstdio.h</code> para evitar hacer uso de todo <code>stdio</code>.</li>
</ul>
<blockquote>
<p><strong>📌 Nota:</strong> En lugar de reinventar la rueda, este capítulo se basa en gran medida en el capítulo correspondiente del libro <em>GTK+/Gnome Application Development</em> de Havoc Pennington, con licencia de Open Publication License (consulte la sección 1.1 p. 3). GLib tiene una API muy estable. A pesar de que el libro de Havoc Pennington fue escrito en 1999 (para GLib 1.2), solo se requirieron algunas actualizaciones para adaptarse a las últimas versiones de GLib (versión 2.42 en el momento de escribir este artículo).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lo-esencial"><a class="header" href="#lo-esencial">Lo esencial</a></h1>
<p>GLib proporciona sustitutos para muchas construcciones de lenguaje C estándar y de uso común. Esta sección describe las definiciones de tipos fundamentales, macros, rutinas de asignación de memoria y funciones de utilidad de cadena de GLib.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="definiciones-de-tipo"><a class="header" href="#definiciones-de-tipo">Definiciones de tipo</a></h1>
<p>En lugar de utilizar los tipos estándar de C (<code>int</code>, <code>long</code> , etc.), GLib define los suyos propios. Estos sirven para una variedad de propósitos. Por ejemplo, se garantiza que <code>gint32</code> tiene 32 bits de ancho, algo que ningún tipo C89 estándar puede garantizar. <code>guint</code> es simplemente más fácil de escribir que <code>unsigned</code> . Algunos de los typedefs existen solo por coherencia; por ejemplo, <code>gchar</code> siempre es equivalente al <code>char</code> estándar.</p>
<p>Los tipos primitivos más importantes definidos por GLib:</p>
<ul>
<li><code>gint8</code>, <code>guint8</code>, <code>gint16</code>, <code>guint16</code>, <code>gint32</code>, <code>guint32</code>, <code>gint64</code>, <code>guint64</code> --- le dará números enteros de un tamaño garantizado. (Si no es obvio, los tipos <code>guint</code> son <code>unsigned</code>, los tipos de <code>gint</code> son <code>signed</code>).</li>
<li><code>gboolean</code> es útil para hacer su código más legible, ya que C89 no tiene un tipo bool.</li>
<li><code>gchar</code>, <code>gshort</code>, <code>glong</code>, <code>gint</code>, <code>gfloat</code>, <code>gdouble</code> son puramente cosméticos.</li>
<li><code>gpointer</code> puede ser más conveniente de escribir que <code>void *</code>. <code>gconstpointer</code> le da <code>const void *</code>. (<code>const gpointer</code> no hará lo que normalmente quiere; dedique un tiempo a leer un buen libro sobre C si no ve por qué).</li>
<li><code>gsize</code> es un tipo entero sin signo que puede contener el resultado del operador <code>sizeof</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros-de-uso-frecuente"><a class="header" href="#macros-de-uso-frecuente">Macros de uso frecuente</a></h1>
<p>GLib define una serie de macros familiares que se utilizan en muchos programas C, que se muestran en el <span class="glib-simplemacros"></span>. Todos estos deben ser autoexplicativos. <code>MIN()</code>/<code>MAX()</code> devuelven el menor o mayor de sus argumentos. <code>ABS()</code> devuelve el valor absoluto de su argumento. <code>CLAMP(x, low, high)</code> significa <code>x</code>, a menos que <code>x</code> esté fuera del rango [<code>low</code>, <code>high</code>]; si <code>x</code> está por debajo del rango, se devuelve <code>low</code>; si x está por encima del rango, se devuelve <code>high</code>. Además de las macros que se muestran en el <span class="glib-simplemacros"></span>, <code>TRUE</code>/<code>FALSE</code>/<code>NULL</code> se definen como los habituales <code>1</code>/<code>0</code>/<code>((void *)0)</code>.</p>
<p><a id="glib-simplemacros"></a></p>
<pre><code class="language-c">#include &lt;glib.h&gt;

MAX (a, b);
MIN (a, b);
ABS (x);
CLAMP (x, low, high);
</code></pre>
<div class="caption">
<p><span class="glib-simplemacros"></span>: Macros C familiares.</p>
</div>
<p>También hay muchas macros exclusivas de GLib, como las conversiones portátiles <code>gpointer</code>-to-<code>gint</code> y <code>gpointer</code>-to-<code>guint</code> que se muestran en el <span class="glib-pointerint"></span>.</p>
<p><a id="glib-pointerint"></a></p>
<pre><code class="language-c">#include &lt;glib.h&gt;

GINT_TO_POINTER (p);
GPOINTER_TO_INT (p);
GUINT_TO_POINTER (p);
GPOINTER_TO_UINT (p);
</code></pre>
<div class="caption">
<p><span class="glib-pointerint"></span>: Macros para almacenar enteros en punteros.</p>
</div>
<p>La mayoría de las estructuras de datos de GLib están diseñadas para almacenar un <code>gpointer</code>. Si desea almacenar punteros a objetos asignados dinámicamente, esto es lo correcto. Sin embargo, a veces desea almacenar una lista simple de números enteros sin tener que asignarlos dinámicamente. Aunque el estándar C no lo garantiza estrictamente, es posible almacenar un <code>gint</code> o <code>guint</code> en una variable <code>gpointer</code> en la amplia gama de plataformas a las que GLib ha sido portado; en algunos casos, se requiere un yeso intermedio. Las macros en el <span class="glib-pointerint"></span> abstraen la presencia del elenco.</p>
<p>He aquí un ejemplo:</p>
<pre><code class="language-c">gint my_int;
gpointer my_pointer;

my_int = 5;
my_pointer = GINT_TO_POINTER (my_int);
printf (&quot;We are storing %d\n&quot;, GPOINTER_TO_INT (my_pointer));
</code></pre>
<p>Pero ten cuidado; estas macros le permiten almacenar un entero en un puntero, pero almacenar un puntero en un entero <em>no</em> funcionará. Para hacerlo de forma portátil, debe almacenar el puntero en un <code>long</code>. (Sin embargo, sin duda es una mala idea hacerlo).</p>
<script>
/* Asignacion de indice de listados en todo la pagina */

let lst = 0;
let i = 0;

lst += 1
let lst01 = document.getElementsByClassName("glib-simplemacros");
for( i = 0; i < lst01.length; i++ ) {
    lst01[i].innerHTML = "<a href=\"#glib-simplemacros\">Listado 2." + lst + "</a>";
}

lst += 1
let lst02 = document.getElementsByClassName("glib-pointerint");
for( i = 0; i < lst02.length; i++ ) {
    lst02[i].innerHTML = "<a href=\"#glib-pointerint\">Listado 2." + lst + "</a>";
}

</script><div style="break-before: page; page-break-before: always;"></div><h1 id="macros-de-depuración"><a class="header" href="#macros-de-depuración">Macros de depuración</a></h1>
<p>GLib tiene un buen conjunto de macros que puede usar para hacer cumplir invariantes y condiciones previas en su código. GTK los usa generosamente, una de las razones por las que es tan estable y fácil de usar. Todos desaparecen cuando define <code>G_DISABLE_CHECKS</code> o <code>G_DISABLE_ASSERT</code>, por lo que no hay penalización de rendimiento en el código de producción. Usarlos generosamente es una muy, muy buena idea. Encontrará errores mucho más rápido si lo hace. Incluso puede agregar afirmaciones y verificaciones cada vez que encuentre un error para asegurarse de que el error no vuelva a aparecer en versiones futuras; esto complementa un conjunto de regresión. Las comprobaciones son especialmente útiles cuando el código que está escribiendo será utilizado como caja negra por otros programadores; los usuarios sabrán inmediatamente cuándo y cómo han hecho un mal uso de su código.</p>
<p>Por supuesto, debe tener mucho cuidado de asegurarse de que su código no dependa sutilmente de declaraciones de solo depuración para funcionar correctamente. Las declaraciones que desaparecerán en el código de producción <em>nunca</em> deberían tener efectos secundarios.</p>
<p><a id="glib-precondition"></a></p>
<pre><code class="language-c">#include &lt;glib.h&gt;

g_return_if_fail (condition);
g_return_val_if_fail (condition, return_value);
</code></pre>
<div class="caption">
<p><span class="glib-precondition"></span>: Comprobaciones de condiciones previas.</p>
</div>
<p>El <span class="glib-precondition"></span> muestra las verificaciones de condiciones previas de GLib. <code>g_return_if_fail()</code> imprime una advertencia y regresa inmediatamente de la función actual si <code>condition</code> es <code>FALSE</code>. <code>g_return_val_if_fail()</code> es similar pero le permite devolver algún <code>return_value</code>. Estos macros son increíblemente útiles, si las usa libremente, especialmente en
combinación con la verificación de tipo en tiempo de ejecución de GObject, reducirá a la mitad el tiempo que dedica a buscar punteros incorrectos y errores
tipográficos.</p>
<p>Usar estas funciones es simple; aquí hay un ejemplo de la implementación de la tabla hash GLib:</p>
<pre><code class="language-c">void
g_hash_table_foreach (GHashTable *hash_table,
                      GHFunc      func,
                      gpointer    user_data)
{
  gint i;

  g_return_if_fail (hash_table != NULL);
  g_return_if_fail (func != NULL);

  for (i = 0; i &lt; hash_table-&gt;size; i++)
    {
      guint node_hash = hash_table-&gt;hashes[i];
      gpointer node_key = hash_table-&gt;keys[i];
      gpointer node_value = hash_table-&gt;values[i];

      if (HASH_IS_REAL (node_hash))
        (* func) (node_key, node_value, user_data);
    }
}
</code></pre>
<p>Sin las comprobaciones, pasar <code>NULL</code> como parámetro a esta función resultaría en una misteriosa falla de segmentación. La persona que usa la biblioteca tendría que averiguar dónde ocurrió el error con un depurador y tal vez incluso indagar en el código GLib para ver qué estaba mal. Con las comprobaciones, obtendrán un bonito mensaje de error que les indicará que los argumentos <code>NULL</code> no están permitidos.</p>
<p><a id="glib-assertions"></a></p>
<pre><code class="language-c">#include &lt;glib.h&gt;

g_assert (condition);
g_assert_not_reached ();
</code></pre>
<div class="caption">
<p><span class="glib-assertions"></span>: Afirmaciones.</p>
</div>
<p>GLib también tiene macros de aserción más tradicionales, que se muestran en el <span class="glib-assertions"></span>. <code>g_assert()</code> es básicamente idéntico a <code>assert()</code>, pero responde a <code>G_DISABLE_ASSERT</code> y se comporta consistentemente en todas las plataformas. También se proporciona <code>g_assert_not_reached()</code>; esta es una afirmación que siempre falla. Las afirmaciones llaman a <code>abort()</code> para salir del programa y (si su entorno lo admite) descargan un archivo central con fines de depuración.</p>
<p>Las afirmaciones fatales deben usarse para verificar la <em>consistencia interna</em> de una función o biblioteca, mientras que <code>g_return_if_fail()</code> está destinado a garantizar que se pasen valores cuerdos a las interfaces públicas de un módulo de programa. Es decir, si una aserción falla, normalmente busca un error en el módulo que contiene la aserción; Si falla una comprobación de <code>g_return_if_fail()</code>, normalmente busca el error en el código que invoca el módulo.</p>
<p>Este código del módulo de cálculos calendáricos de GLib muestra la diferencia:</p>
<pre><code class="language-c">GDate *
g_date_new_dmy (GDateDay   day,
                GDateMonth month,
                GDateYear  year)
{
  GDate *date;
  g_return_val_if_fail (g_date_valid_dmy (day, month, year), NULL);

  date = g_new (GDate, 1);

  date-&gt;julian = FALSE;
  date-&gt;dmy = TRUE;

  date-&gt;month = month;
  date-&gt;day = day;
  date-&gt;year = year;

  g_assert (g_date_valid (date));

  return date;
}
</code></pre>
<p>La verificación de condiciones previas al principio asegura que el usuario pasa en valores razonables para el día, mes y año; la afirmación al final asegura que GLib construyó un objeto sano, dados valores cuerdos.</p>
<p><code>g_assert_not_reached()</code> debe usarse para marcar situaciones &quot;imposibles&quot;; un uso común es detectar declaraciones de cambio que no manejan todos los valores posibles de una enumeración:</p>
<pre><code class="language-c">switch (value)
  {
  case FOO_ONE:
    break;

  case FOO_TWO:
    break;

  default:
    g_assert_not_reached ();
  }
</code></pre>
<p>Todas las macros de depuración imprimen una advertencia utilizando la función <code>g_log()</code> de GLib, lo que significa que la advertencia incluye el nombre de la aplicación o biblioteca de origen y, opcionalmente, puede instalar una rutina de impresión de advertencias de reemplazo. Por ejemplo, puede enviar todas las advertencias a un cuadro de diálogo o archivo de registro en lugar de imprimirlas en la consola.</p>
<script>
/* Asignacion de indice de listados en todo la pagina */

let lst = 2;
let i = 0;

lst += 1
let lst01 = document.getElementsByClassName("glib-precondition");
for( i = 0; i < lst01.length; i++ ) {
    lst01[i].innerHTML = "<a href=\"#glib-precondition\">Listado 2." + lst + "</a>";
}

lst += 1
let lst02 = document.getElementsByClassName("glib-assertions");
for( i = 0; i < lst02.length; i++ ) {
    lst02[i].innerHTML = "<a href=\"#glib-assertions\">Listado 2." + lst + "</a>";
}

</script><div style="break-before: page; page-break-before: always;"></div><h1 id="memoria"><a class="header" href="#memoria">Memoria</a></h1>
<p>GLib envuelve el estándar <code>malloc()</code> y <code>free()</code> con sus propias variantes <code>g_</code>, <code>g_malloc()</code> y <code>g_free()</code>, que se muestran en el <span class="glib-malloc-free"></span>. Estos son agradables de varias maneras pequeñas:</p>
<ul>
<li>
<p><code>g_malloc()</code> siempre devuelve un <code>gpointer</code>, nunca un <code>char *</code>, por lo que no es necesario emitir el valor de retorno.</p>
</li>
<li>
<p><code>g_malloc()</code> aborta el programa si el <code>malloc()</code> subyacente falla, por lo que no tiene que buscar un valor devuelto <code>NULL</code>.</p>
</li>
<li>
<p><code>g_malloc()</code> maneja con gracia un <code>size</code> de <code>0</code>, devolviendo <code>NULL</code>.</p>
</li>
<li>
<p><code>g_free()</code> ignorará cualquier puntero <code>NULL</code> que le pase.</p>
</li>
</ul>
<blockquote>
<p><strong>📌 Nota:</strong> Antes del estándar ANSI/ISO C, el tipo de puntero genérico <code>void *</code> no existía y <code>malloc()</code> devolvía un valor <code>char *</code>. Actualmente, <code>malloc()</code> devuelve un tipo <code>void *</code> (que es lo mismo que <code>gpointer</code>) y <code>void *</code> permite conversiones de puntero implícitas en C. Lanzando el valor de retorno de <code>malloc()</code> es necesario si: el desarrollador quiere admitir compiladores antiguos; o si el desarrollador piensa que una conversión explícita aclara el código; o si se usa un compilador de C++, porque en C++ se requiere una conversión del tipo <code>void *</code>.</p>
</blockquote>
<p><a id="glib-malloc-free"></a></p>
<pre><code class="language-c">#include &lt;glib.h&gt;

gpointer g_malloc (gsize n_bytes);
void g_free (gpointer mem);
gpointer g_realloc (gpointer mem, gsize n_bytes);
gpointer g_memdup (gconstpointer mem, guint n_bytes);
</code></pre>
<div class="caption">
<p><span class="glib-malloc-free"></span>: Asignación de memoria GLib</p>
</div>
<p>Es importante hacer coincidir <code>g_malloc()</code> con <code>g_free()</code>, <code>malloc()</code> simple con <code>free()</code> y si estás usando C++ <code>new</code> con <code>delete</code>. De lo contrario, pueden suceder errores, ya que estos asignadores pueden usar diferentes grupos de memoria (y <code>new</code>/<code>delete</code> llama a constructores y destructores).</p>
<p>Por supuesto, hay un <code>g_realloc()</code> equivalente a <code>realloc()</code>. También hay un conveniente <code>g_malloc0()</code> que llena la memoria asignada con ceros, y <code>g_memdup()</code> que devuelve una copia de <code>n_bytes</code> bytes comenzando en <code>mem</code>. <code>g_realloc()</code> y <code>g_malloc0()</code> aceptarán ambos un tamaño de 0, por coherencia con <code>g_malloc()</code>. Sin embargo, <code>g_memdup()</code> no lo hará.</p>
<p>Si no es obvio: <code>g_malloc0()</code> llena la memoria sin procesar con bits no configurados, no el valor 0 para cualquier tipo que pretenda poner allí. De vez en cuando, alguien espera obtener una matriz de números de coma flotante inicializados en 0.0; <em>no</em> se garantiza que funcione de forma portátil.</p>
<p>Por último, existen macros de asignación con reconocimiento de tipos, que se muestran en el <span class="glib-g_new"></span>. El argumento <code>type</code> para cada uno de estos es el nombre de un tipo, y el argumento <code>count</code> es el número de bloques de tamaño <code>type</code> a asignar. Estas macros le ahorran algo de escritura y multiplicación y, por lo tanto, son menos propensas a errores. Se lanzan automáticamente al tipo de puntero de destino, por lo que intentar asignar la memoria asignada al tipo de puntero incorrecto debería activar una advertencia del compilador. (Si tiene las advertencias activadas, ¡como debería hacerlo un programador responsable!)</p>
<p><a id="glib-g_new"></a></p>
<pre><code class="language-c">#include &lt;glib.h&gt;

g_new (type, count);
g_new0 (type, count);
g_renew (type, mem, count);
</code></pre>
<div class="caption">
<p><span class="glib-g_new"></span>: Macros de asignación</p>
</div>
<script>
/* Asignacion de indice de listados en todo la pagina */

let lst = 4;
let i = 0;

lst += 1
let lst01 = document.getElementsByClassName("glib-malloc-free");
for( i = 0; i < lst01.length; i++ ) {
    lst01[i].innerHTML = "<a href=\"#glib-malloc-free\">Listado 2." + lst + "</a>";
}

lst += 1
let lst02 = document.getElementsByClassName("glib-g_new");
for( i = 0; i < lst02.length; i++ ) {
    lst02[i].innerHTML = "<a href=\"#glib-g_new\">Listado 2." + lst + "</a>";
}

</script><div style="break-before: page; page-break-before: always;"></div><h1 id="manejo-de-string"><a class="header" href="#manejo-de-string">Manejo de string</a></h1>
<p>GLib proporciona una serie de funciones para el manejo de cadenas; algunos son exclusivos de GLib y otros resuelven problemas de portabilidad. Todos interoperan muy bien con las rutinas de asignación de memoria GLib.</p>
<p>Para aquellos interesados en una cadena mejor que <code>gchar *</code>, también hay un tipo <code>GString</code>. No se trata en este libro; consulte la documentación de la API para obtener más información.</p>
<p><a id="glib-strext"></a></p>
<pre><code class="language-c">gint g_snprintf (gchar *string, gulong n, gchar const *format, ...);
</code></pre>
<div class="caption">
<p><span class="glib-strext"></span>: Envoltorio de portabilidad.</p>
</div>
<p>El <span class="glib-strext"></span> muestra un sustituto que GLib proporciona para la función <code>snprintf()</code>. <code>g_snprintf()</code> envuelve el <code>snprintf()</code> nativo en las plataformas que lo tienen y proporciona una implementación en las que no lo tienen.</p>
<p>Preste atención a no usar la función <code>sprintf()</code> que causa fallas, crea agujeros de seguridad y generalmente es maligna. Al usar <code>g_snprintf()</code> o <code>g_strdup_printf()</code> relativamente seguros (ver más abajo), puedes despedirte de <code>sprintf()</code> para siempre.</p>
<p><a id="glib-strdup"></a></p>
<pre><code>#include &lt;glib.h&gt;

gchar * g_strdup (const gchar *str);
gchar * g_strndup (const gchar *str, gsize n);
gchar * g_strdup_printf (const gchar *format, ...);
gchar * g_strdup_vprintf (const gchar *format, va_list args);
gchar * g_strnfill (gsize length, gchar fill_char);
</code></pre>
<div class="caption">
<p><span class="glib-strdup"></span>: Asignar cadenas.</p>
</div>
<p>El <span class="glib-strdup"></span> muestra la amplia gama de funciones de GLib para asignar cadenas. Como era de esperar, <code>g_strdup()</code> y <code>g_strndup()</code> producen una copia asignada de <code>str</code> o los primeros <code>n</code> caracteres de <code>str</code>. Para mantener la coherencia con las funciones de asignación de memoria GLib, devuelven <code>NULL</code> si se les pasa un puntero <code>NULL</code>. Las variantes <code>printf()</code> devuelven una cadena formateada. <code>g_strnfill()</code> devuelve una cadena de tamaño <code>length</code> rellena con <code>fill_char</code>.</p>
<p><code>g_strdup_printf()</code> merece una mención especial; es una forma más sencilla de manejar este código común:</p>
<pre><code class="language-c">gchar *str = g_malloc (256);
g_snprintf (str, 256, &quot;%d printf-style %s&quot;, num, string);
</code></pre>
<p>En su lugar, podría decir esto y evitar tener que averiguar la longitud adecuada del búfer para arrancar:</p>
<pre><code class="language-c">gchar *str = g_strdup_printf (&quot;%d printf-style %s&quot;, num, string);
</code></pre>
<p><a id="glib-strmanip"></a></p>
<pre><code class="language-c">#include &lt;glib.h&gt;

gchar * g_strchug (gchar *string);
gchar * g_strchomp (gchar *string);
gchar * g_strstrip (gchar *string);
</code></pre>
<div class="caption">
<p><span class="glib-strmanip"></span>: Modificaciones de cadenas in situ.</p>
</div>
<p>Las funciones del <span class="glib-strmanip"></span> modifican una cadena en el lugar: <code>g_strchug ()</code> y <code>g_strchomp()</code> &quot;chug&quot; la cadena (elimina los espacios iniciales), o &quot;chomp&quot; (eliminar los espacios finales). Esas dos funciones devuelven la cadena, además de modificarla en el lugar; en algunos casos, puede ser conveniente utilizar el valor de retorno. Hay una macro, <code>g_strstrip()</code>, que combina ambas funciones para eliminar los espacios iniciales y finales.</p>
<p><a id="glib-strformats"></a></p>
<pre><code class="language-c">#include &lt;glib.h&gt;

gdouble g_strtod (const gchar *nptr, gchar **endptr);
const gchar * g_strerror (gint errnum);
const gchar * g_strsignal (gint signum);
</code></pre>
<div class="caption">
<p><span class="glib-strformats"></span>: Conversiones de cadenas.</p>
</div>
<p>El listado 2.10 muestra algunas funciones semi-estándar más que envuelve GLib. <code>g_strtod</code> es como <code>strtod()</code> -- convierte la cadena <code>nptr</code> en un double -- con la excepción de que también intentará convertir el double en la configuración local de <code>&quot;C&quot;</code> si no puede convertirlo en la configuración local predeterminada del usuario. <code>*endptr</code> se establece en el primer carácter no convertido, es decir, cualquier texto después de la representación numérica. Si la conversión falla, <code>*endptr</code> se establece en <code>nptr</code>. <code>endptr</code> puede ser <code>NULL</code>, lo que hace que se ignore.</p>
<p><code>g_strerror()</code> y <code>g_strsignal()</code> son como sus equivalentes no <code>g_ </code>, pero portátiles. (Devuelven una representación de cadena para un errno o un número de señal).</p>
<p><a id="glib-strconcat"></a></p>
<pre><code>#include &lt;glib.h&gt;

gchar * g_strconcat (const gchar *string1, ...);
gchar * g_strjoin (const gchar *separator, ...);
</code></pre>
<div class="caption">
<p><span class="glib-strconcat"></span>: Concatenar cadenas.</p>
</div>
<p>GLib proporciona algunas funciones convenientes para concatenar cadenas, que se muestran en el <span class="glib-strconcat"></span>. <code>g_strconcat()</code> devuelve una cadena recién asignada creada concatenando cada una de las cadenas en la lista de argumentos. El último argumento debe ser <code>NULL</code>, por lo que <code>g_strconcat()</code> sabe cuándo detenerse. <code>g_strjoin()</code> es similar, pero <code>separator</code> se inserta entre cada cadena. Si <code>separator</code> es <code>NULL</code> , no se usa ningún separador.</p>
<p><a id="glib-strvector"></a></p>
<pre><code>#include &lt;glib.h&gt;

gchar ** g_strsplit (const gchar *string,
                     const gchar *delimiter,
                     gint max_tokens);
gchar * g_strjoinv (const gchar *separator, gchar **str_array);
void g_strfreev (gchar **str_array);
</code></pre>
<div class="caption">
<p><span class="glib-strvector"></span>: Manipulación de vectores de cadena terminados en <code>NULL</code>.</p>
</div>
<p>Finalmente, el <span class="glib-strvector"></span> resume algunas rutinas que manipulan matrices de cadenas terminadas en <code>NULL</code>. <code>g_strsplit()</code> rompe <code>string</code> en cada <code>delimiter</code>, devolviendo una matriz recién asignada. <code>g_strjoinv()</code> concatena cada cadena en la matriz con un <code>separator</code> opcional, devolviendo una cadena asignada. <code>g_strfreev()</code> libera cada cadena en la matriz y luego la propia matriz.</p>
<script>
/* Asignacion de indice de listados en todo la pagina */

let lst = 6;
let i = 0;

lst += 1
let lst01 = document.getElementsByClassName("glib-strext");
for( i = 0; i < lst01.length; i++ ) {
    lst01[i].innerHTML = "<a href=\"#glib-strext\">Listado 2." + lst + "</a>";
}

lst += 1
let lst02 = document.getElementsByClassName("glib-strdup");
for( i = 0; i < lst02.length; i++ ) {
    lst02[i].innerHTML = "<a href=\"#glib-strdup\">Listado 2." + lst + "</a>";
}

lst += 1
let lst03 = document.getElementsByClassName("glib-strmanip");
for( i = 0; i < lst03.length; i++ ) {
    lst03[i].innerHTML = "<a href=\"#glib-strmanip\">Listado 2." + lst + "</a>";
}

lst += 1
let lst04 = document.getElementsByClassName("glib-strformats");
for( i = 0; i < lst04.length; i++ ) {
    lst04[i].innerHTML = "<a href=\"#glib-strformats\">Listado 2." + lst + "</a>";
}

lst += 1
let lst05 = document.getElementsByClassName("glib-strconcat");
for( i = 0; i < lst05.length; i++ ) {
    lst05[i].innerHTML = "<a href=\"#glib-strconcat\">Listado 2." + lst + "</a>";
}

lst += 1
let lst06 = document.getElementsByClassName("glib-strvector");
for( i = 0; i < lst06.length; i++ ) {
    lst06[i].innerHTML = "<a href=\"#glib-strvector\">Listado 2." + lst + "</a>";
}
</script><div style="break-before: page; page-break-before: always;"></div><h1 id="bibliografía"><a class="header" href="#bibliografía">Bibliografía</a></h1>
<ol>
<li>
<p><a id="k-r-book"></a> Brian Kernighan and Dennis Ritchie, <em><strong>The C Programming Language</strong></em>, Second Edition, Prentice Hall, 1988.</p>
</li>
<li>
<p><a id="oop-book"></a> Arthur Riel, <em><strong>Object-Oriented Design Heuristics</strong></em>, Addison-Wesley, 1996.</p>
</li>
<li>
<p><a id="design-patterns-book"></a> Gamma E., Helm R., Johnson R., Vlissides J., <em><strong>Design Patterns: Elements of Reusable Object-Oriented Software</strong></em>, Addison-Wesley Professional, 1994.</p>
</li>
<li>
<p><a id="algo-book"></a> Steven Skiena, <em><strong>The Algorithm Design Manual</strong></em>, Second Edition, Springer, 2008.</p>
</li>
<li>
<p><a id="unix-impatient"></a> Paul Abrahams, <em><strong>UNIX for the Impatient</strong></em>, Second Edition, Addison-Wesley, 1995.</p>
</li>
<li>
<p><a id="pro-git"></a> Scott Chacon, <em><strong>Pro Git</strong></em>, <a href="https://git-scm.com/book">git-scm.com/book</a></p>
</li>
<li>
<p><a id="autotools"></a> John Calcote, <em><strong>Autotools: A Practitioner's Guide to GNU Autoconf, Automake, and Libtool</strong></em>, No Starch Press, 2010.</p>
</li>
<li>
<p><a id="code-complete"></a> Steve McConnell, <em><strong>Code Complete: A practical handbook of software construction</strong></em>, Second Edition, Microsoft Press, 2004.</p>
</li>
<li>
<p><a id="gtk-doc"></a> <em><strong>GTK-Doc Manual</strong></em>, <a href="https://developer.gnome.org/gtk-doc-manual/">developer.gnome.org/gtk-doc-manual/</a></p>
</li>
<li>
<p><a id="gobject-introspection"></a> <em><strong>GObject Introspection</strong></em>, <a href="https://wiki.gnome.org/Projects/GObjectIntrospection">wiki.gnome.org/Projects/GObjectIntrospection</a></p>
</li>
<li>
<p><a id="gnome-programming-guidelines"></a> <em><strong>GNOME Programming Guidelines</strong></em>, <a href="https://developer.gnome.org/programming-guidelines/stable/">developer.gnome.org/programming-guidelines/stable/</a></p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
